package com.sumologic.terraform_generator.writer

import com.sumologic.terraform_generator.objects._

case class AcceptanceTestFileGenerator(terraform: TerraformResource, mainClass: String)
  extends TerraformFileGeneratorBase(terraform: TerraformResource) {

  val functionGenerator = AcceptanceTestFunctionGenerator(
    terraform,
    terraform.getAllTypesUsed.filter(_.name.toLowerCase.contains(mainClass.toLowerCase)).head
  )

  def generate(): String = {
    val pre = s"""// ----------------------------------------------------------------------------
                 |//
                 |//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
                 |//
                 |// ----------------------------------------------------------------------------
                 |//
                 |//     This file is automatically generated by Sumo Logic and manual
                 |//     changes will be clobbered when the file is regenerated. Do not submit
                 |//     changes to this file.
                 |//
                 |// ----------------------------------------------------------------------------
                 |package sumologic
                 |
                 |import (
                 |	"fmt"
                 |	"testing"
                 |  "strconv"
                 |  "strings"
                 |	"github.com/hashicorp/terraform-plugin-sdk/helper/resource"
                 |	"github.com/hashicorp/terraform-plugin-sdk/terraform"
                 |)
                 |""".stripMargin


    val endpoints = terraform.endpoints.filter { endpoint =>
      endpoint.endpointType == TerraformPathExtensions.Read
    }
    assert(endpoints.size == 1, s"More than one Get endpoint? [$endpoints]")

    // We can have path parameter other than 'id'. Assuming for CRUD endpoints, we won't have any path
    // parameter other than 'id'.
    val hasPathParam: Boolean = endpoints.head.parameters.map(_.paramType).exists { param =>
      param.contains(TerraformSupportedParameterTypes.PathParameter)
    }

    pre +
      functionGenerator.generateTestFunctionCreateBasic() + "\n" +
      functionGenerator.generateTestFunctionCreate() + "\n" +
      functionGenerator.generateTestFunctionUpdate() + "\n" +
      functionGenerator.generateTestFunctionDestroy(hasPathParam) + "\n" +
      functionGenerator.generateTestFunctionExists(hasPathParam) + "\n" +
      functionGenerator.generateTestImportFunction() + "\n" +
      functionGenerator.generateTestCreateResource() + "\n" +
      functionGenerator.generateTestUpdateResource() + "\n" +
      functionGenerator.generateTestResourceAttributes()
  }
}

case class AcceptanceTestFunctionGenerator(terraformResource: TerraformResource, mainClass: OpenApiType)
    extends AcceptanceTestGeneratorHelper {

  val className = mainClass.name
  val objName = lowerCaseFirstLetter(className)
  val resourceProps = terraformResource.getAllTypesUsed.head

  def generateTestFunctionCreateBasic(): String = {
    val setters = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop => s"""test${prop.getName.capitalize} := ${getTestValue(prop)}"""
    }.mkString("\n  ")

    val testNames = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        s"""test${prop.getName.capitalize}"""
    }.mkString(", ")

    s"""func TestAccSumologic${className}_basic(t *testing.T) {
       |	var $objName $className
       |	$setters
       |
       |	resource.Test(t, resource.TestCase{
       |		PreCheck:     func() { testAccPreCheck(t) },
       |		Providers:    testAccProviders,
       |		CheckDestroy: testAccCheck${className}Destroy($objName),
       |		Steps: []resource.TestStep{
       |			{
       |				Config: testAccCheckSumologic${className}ConfigImported($testNames),
       |			},
       |			{
       |				ResourceName:      "sumologic_${removeCamelCase(objName)}.foo",
       |				ImportState:       true,
       |				ImportStateVerify: true,
       |			},
       |		},
       |	})
       |}""".stripMargin
  }

  def generateTestFunctionCreate(): String = {
    val setters = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop => s"""test${prop.getName.capitalize} := ${getTestValue(prop)}"""
    }.mkString("\n  ")

    val testNames = "(" + filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        s"""test${prop.getName.capitalize}"""
    }.mkString(", ")

    val checkAttr = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        val name = s"sumologic_${removeCamelCase(objName)}.test"
        val key = removeCamelCase(prop.getName)
        val value = prop.getName.capitalize

        prop.getType.name match {
          case "bool" =>
            s"""resource.TestCheckResourceAttr("$name", "$key", strconv.FormatBool(test${value})),"""
          case "int" =>
            s"""resource.TestCheckResourceAttr("$name", "$key", strconv.Itoa(test${value})),"""
          case "array" =>
            s"""resource.TestCheckResourceAttr("$name", "${key}.0", strings.Replace(test${value}[0], "\\"", "", 2)),"""
          case _ =>
            if (prop.isInstanceOf[OpenApiArrayObject]) {
              s"""resource.TestCheckResourceAttr("$name", "${key}.0", strings.Replace(test${value}[0], "\\"", "", 2)),"""
            } else {
              s"""resource.TestCheckResourceAttr("$name", "$key", test${value}),"""
            }
        }
    }.mkString("\n          ")

    s"""func TestAcc${className}_create(t *testing.T) {
       |  var ${objName} ${className}
       |  $setters
       |  resource.Test(t, resource.TestCase{
       |    PreCheck: func() { testAccPreCheck(t) },
       |    Providers:    testAccProviders,
       |    CheckDestroy: testAccCheck${className}Destroy(${objName}),
       |    Steps: []resource.TestStep{
       |      {
       |        Config: testAccSumologic${className}$testNames),
       |        Check: resource.ComposeTestCheckFunc(
       |          testAccCheck${className}Exists("sumologic_${{removeCamelCase(objName)}}.test", &${objName}, t),
       |          testAccCheck${className}Attributes("sumologic_${{removeCamelCase(objName)}}.test"),
       |          $checkAttr
       |        ),
       |      },
       |    },
       |  })
       |}""".stripMargin
  }

  def generateTestFunctionDestroy(hasPathParam: Boolean): String = {
    val getCall = if (hasPathParam) s"Get${className}(id)" else s"Get${className}()"

    s"""
       |func testAccCheck${className}Destroy(${objName} ${className}) resource.TestCheckFunc {
       |	return func(s *terraform.State) error {
       |		client := testAccProvider.Meta().(*Client)
       |    for _, r := range s.RootModule().Resources {
       |      id := r.Primary.ID
       |		  u, err := client.$getCall
       |		  if err != nil {
       |        return fmt.Errorf("Encountered an error: " + err.Error())
       |		  }
       |      if u != nil {
       |        return fmt.Errorf("${className} %s still exists", id)
       |      }
       |    }
       |		return nil
       |	}
       |}
       |""".stripMargin
  }

  def generateTestFunctionExists(hasPathParam: Boolean): String = {
    val getCall = if (hasPathParam) s"Get${className}(id)" else s"Get${className}()"

    s"""func testAccCheck${className}Exists(name string, ${objName} *${className}, t *testing.T) resource.TestCheckFunc {
       |	return func(s *terraform.State) error {
       |		rs, ok := s.RootModule().Resources[name]
       |		if !ok {
       |      //need this so that we don't get an unused import error for strconv in some cases
       |			return fmt.Errorf("Error = %s. ${className} not found: %s", strconv.FormatBool(ok), name)
       |		}
       |
       |    //need this so that we don't get an unused import error for strings in some cases
       |		if strings.EqualFold(rs.Primary.ID, "") {
       |			return fmt.Errorf("${className} ID is not set")
       |		}
       |
       |		id := rs.Primary.ID
       |		client := testAccProvider.Meta().(*Client)
       |		new${className}, err := client.$getCall
       |		if err != nil {
       |			return fmt.Errorf("${className} %s not found", id)
       |		}
       |		${objName} = new${className}
       |		return nil
       |	}
       |}""".stripMargin
  }

  def generateTestFunctionUpdate(): String = {
    val testArguments = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop => s"""test${prop.getName.capitalize} := ${getTestValue(prop)}"""
    }.mkString("\n  ")

    val testUpdateArguments = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        val unique = prop.getAttribute == TerraformPropertyAttributes.UNIQUE
        if (unique && prop.getCreateOnly) {
          testArguments.split("\n").filter {
            arg => arg.contains(s"test${prop.getName.capitalize}")
          }.head.replace(s"test${prop.getName.capitalize}", s"testUpdated${prop.getName.capitalize}")
        } else {
          s"""testUpdated${prop.getName.capitalize} := ${getTestValue(prop, isUpdate = true)}"""
        }
    }.mkString("\n  ")

    val argList = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop => s"""test${prop.getName.capitalize}"""
    }.mkString(", ")

    val checkAttr = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        val name = s"sumologic_${removeCamelCase(objName)}.test"
        val key = removeCamelCase(prop.getName)
        val value = s"test${prop.getName.capitalize}"

        prop.getType.name match {
          case "bool" =>
            s"""resource.TestCheckResourceAttr("$name", "${key}", strconv.FormatBool(${value})),"""
          case "int" =>
            s"""resource.TestCheckResourceAttr("$name", "${key}", strconv.Itoa(${value})),"""
          case "array" =>
            s"""resource.TestCheckResourceAttr("$name", "${key}.0", strings.Replace(${value}[0], "\\"", "", 2)),"""
          case _ =>
            if (prop.isInstanceOf[OpenApiArrayObject]) {
              s"""resource.TestCheckResourceAttr("$name", "${key}.0", strings.Replace(${value}[0], "\\"", "", 2)),"""
            } else {
              s"""resource.TestCheckResourceAttr("$name", "${key}", ${value}),"""
            }
        }
    }.mkString("\n          ")

    val updateArgList = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop => s"""testUpdated${prop.getName.capitalize}"""
    }.mkString(", ")

    val checkUpdateAttr = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        val name = s"sumologic_${removeCamelCase(objName)}.test"
        val key = removeCamelCase(prop.getName)
        val value = s"testUpdated${prop.getName.capitalize}"

        prop.getType.name match {
          case "bool" =>
            s"""resource.TestCheckResourceAttr("$name", "${key}", strconv.FormatBool(${value})),"""
          case "int" =>
            s"""resource.TestCheckResourceAttr("$name", "${key}", strconv.Itoa(${value})),"""
          case "array" =>
            s"""resource.TestCheckResourceAttr("$name", "${key}.0", strings.Replace(${value}[0], "\\"", "", 2)),"""
          case _ =>
            if (prop.isInstanceOf[OpenApiArrayObject]) {
              s"""resource.TestCheckResourceAttr("$name", "${key}.0", strings.Replace(${value}[0], "\\"", "", 2)),"""
            } else {
              s"""resource.TestCheckResourceAttr("$name", "${key}", ${value}),"""
            }
        }
    }.mkString("\n          ")

    s"""
       |func TestAcc${className}_update(t *testing.T) {
       |  var ${objName} ${className}
       |  $testArguments
       |
       |  $testUpdateArguments
       |
       |	resource.Test(t, resource.TestCase{
       |		PreCheck: func() { testAccPreCheck(t) },
       |		Providers:    testAccProviders,
       |		CheckDestroy: testAccCheck${className}Destroy($objName),
       |		Steps: []resource.TestStep{
       |			{
       |				Config: testAccSumologic${className}($argList),
       |				Check: resource.ComposeTestCheckFunc(
       |					testAccCheck${className}Exists("sumologic_${removeCamelCase(objName)}.test", &$objName, t),
       |					testAccCheck${className}Attributes("sumologic_${removeCamelCase(objName)}.test"),
       |          $checkAttr
       |				),
       |			},
       |			{
       |				Config: testAccSumologic${className}Update($updateArgList),
       |				Check: resource.ComposeTestCheckFunc(
       |					$checkUpdateAttr
       |				),
       |			},
       |		},
       |	})
       |}""".stripMargin
  }

  def generateTestImportFunction(): String = {
    val propArgs = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        val name = if (ForbiddenGoTerms.Forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName
        }
        if (prop.isInstanceOf[OpenApiArrayObject]) {
          s"""${name} ${prop.getGoType}"""
        } else {
          s"""${name} ${TerraformSchemaTypes.openApiTypeToGoType(prop.getType.name.toLowerCase)}"""
        }
    }.mkString(", ")
    val terraformArgs = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        if (prop.isInstanceOf[OpenApiArrayObject]) {
          s"""${removeCamelCase(prop.getName)} = ${TerraformSchemaTypes.openApiTypeToPlaceholder("array")}"""
        } else {
          s"""${removeCamelCase(prop.getName)} = ${TerraformSchemaTypes.openApiTypeToPlaceholder(prop.getType.name)}"""
        }
    }.mkString("\n      ")
    val propList = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        if (ForbiddenGoTerms.Forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName
        }
    }.mkString(", ")
    s"""func testAccCheckSumologic${className}ConfigImported($propArgs) string {
       |	return fmt.Sprintf(`
       |resource "sumologic_${removeCamelCase(objName)}" "foo" {
       |      $terraformArgs
       |}
       |`, $propList)
       |}""".stripMargin
  }

  def generateTestCreateResource(): String = {
    val propArgs = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        val name = if (ForbiddenGoTerms.Forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName
        }
        if (prop.isInstanceOf[OpenApiArrayObject]) {
          s"""${name} ${prop.getGoType}"""
        } else {
          s"""${name} ${TerraformSchemaTypes.openApiTypeToGoType(prop.getType.name.toLowerCase)}"""
        }
    }.mkString(", ")
    val terraformArgs = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        if (prop.isInstanceOf[OpenApiArrayObject]) {
          s"""${removeCamelCase(prop.getName)} = ${TerraformSchemaTypes.openApiTypeToPlaceholder("array")}"""
        } else {
          s"""${removeCamelCase(prop.getName)} = ${TerraformSchemaTypes.openApiTypeToPlaceholder(prop.getType.name)}"""
        }
    }.mkString("\n    ")
    val propList = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        if (ForbiddenGoTerms.Forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName
        }
    }.mkString(", ")

    s"""
       |func testAccSumologic${className}($propArgs) string {
       |	return fmt.Sprintf(`
       |resource "sumologic_${removeCamelCase(objName)}" "test" {
       |    $terraformArgs
       |}
       |`, $propList)
       |}""".stripMargin
  }

  def generateTestUpdateResource(): String = {
    val propArgs = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        val name = if (ForbiddenGoTerms.Forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName
        }
        if (prop.isInstanceOf[OpenApiArrayObject]) {
          s"""${name} ${prop.getGoType}"""
        } else {
          s"""${name} ${TerraformSchemaTypes.openApiTypeToGoType(prop.getType.name.toLowerCase)}"""
        }
    }.mkString(", ")
    val terraformArgs = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        if (prop.isInstanceOf[OpenApiArrayObject]) {
          s"""${removeCamelCase(prop.getName)} = ${TerraformSchemaTypes.openApiTypeToPlaceholder("array")}"""
        } else {
          s"""${removeCamelCase(prop.getName)} = ${TerraformSchemaTypes.openApiTypeToPlaceholder(prop.getType.name)}"""
        }
    }.mkString("\n      ")
    val propList = filterProps(resourceProps.props, List("id", "roleids")).map {
      prop =>
        if (ForbiddenGoTerms.Forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName
        }
    }.mkString(", ")

    s"""
       |func testAccSumologic${className}Update($propArgs) string {
       |	return fmt.Sprintf(`
       |resource "sumologic_${removeCamelCase(objName)}" "test" {
       |      $terraformArgs
       |}
       |`, $propList)
       |}""".stripMargin
  }

  def generateTestResourceAttributes(): String = {
    val checkResourceAttr = filterProps(resourceProps.props, List("id", "roleids", "capabilities")).map {
      prop =>
        s"""resource.TestCheckResourceAttrSet(name, "${removeCamelCase(prop.getName)}"),"""
    }.mkString("\n        ")

    s"""
       |func testAccCheck${className}Attributes(name string) resource.TestCheckFunc {
       |  return func(s *terraform.State) error {
       |      f := resource.ComposeTestCheckFunc(
       |        $checkResourceAttr
       |      )
       |      return f(s)
       |   }
       |}""".stripMargin
  }

  private def filterProps(props: List[OpenApiObject], filterOut: List[String]): List[OpenApiObject] = {
    props.filterNot {
      prop => filterOut.contains(prop.getName.toLowerCase)
    }
  }
}
