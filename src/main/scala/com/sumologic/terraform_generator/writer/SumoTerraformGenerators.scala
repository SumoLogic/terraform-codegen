package com.sumologic.terraform_generator.writer

import java.io.{BufferedWriter, File, FileWriter}

import com.sumologic.terraform_generator.objects.SumoSwaggerSupportedOperations.crud
import com.sumologic.terraform_generator.utils.SumoTerraformUtils._
import com.sumologic.terraform_generator.objects.{ForbiddenGoTerms, SumoSwaggerEndpoint, SumoSwaggerObject, SumoSwaggerObjectArray, SumoSwaggerTemplate, SumoSwaggerType, SumoTerraformEntity}
import com.sumologic.terraform_generator.utils.{SumoTerraformSchemaTypes, SumoTerraformSupportedParameterTypes}

abstract class SumoTerraformFileGenerator(terraform: SumoSwaggerTemplate) {
  def writeToFile(filePath: String): Unit = {
    val text = generate()
    val file = new File(filePath)
    val bw = new BufferedWriter(new FileWriter(file))
    bw.write(text)
    bw.close()
  }


  //TODO pass in the file or output stream
  def generate(): String
}

case class SumoTerraformClassFileGenerator(terraform: SumoSwaggerTemplate)
  extends SumoTerraformFileGenerator(terraform: SumoSwaggerTemplate) {
  def generate(): String = {
    val typesUsed: Set[SumoSwaggerType] = terraform.getAllTypesUsed()

    val intro = s"""// ----------------------------------------------------------------------------
         |//
         |//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
         |//
         |// ----------------------------------------------------------------------------
         |//
         |//     This file is automatically generated by Sumo Logic and manual
         |//     changes will be clobbered when the file is regenerated. Do not submit
         |//     changes to this file.
         |//
         |// ----------------------------------------------------------------------------
         |package sumologic
         |
         |import (
         |  "encoding/json"
         |  "fmt"
         |)
         |""".stripMargin


    val endpointsWithChangedNames = terraform.supportedEndpoints.map {
      endpoint =>
        val name = crud.find(endpoint.endpointName.toLowerCase.contains(_))
        if (name.isDefined) {
          endpoint.copy(endpointName = name.get.toLowerCase + terraform.getMainObjectClass().name.capitalize)
        } else {
          endpoint
        }
    }
    val endpoints = endpointsWithChangedNames.map {
      case endpoint: SumoSwaggerEndpoint =>
        val bodyParams = endpoint.parameters.filter(_.paramType == SumoTerraformSupportedParameterTypes.BodyParameter)
        if (bodyParams.size > 1 || endpoint.responses.filterNot(_.respTypeName.toLowerCase == "default").size > 1) {
          val paramsToExclude = bodyParams.filterNot(_.param.getName.toLowerCase == terraform.sumoSwaggerClassName.toLowerCase)
          val filteredEndpoint = endpoint.copy(parameters = endpoint.parameters diff paramsToExclude, responses = endpoint.responses.filter(_.respTypeName.toLowerCase == terraform.sumoSwaggerClassName.toLowerCase))
          filteredEndpoint.terraformify() + "\n"
        } else {
          endpoint.terraformify() + "\n"
        }
    }.mkString("")

    val types = typesUsed.map {
      case stype: SumoSwaggerType =>
        stype.terraformify() + "\n"
    }.mkString("")

    s"// ---------- BEGIN ${terraform.sumoSwaggerClassName} ----------\n" + intro +
      "\n// ---------- ENDPOINTS ---------- \n\n" + endpoints +
      "\n// ---------- TYPES ----------\n" + types +
      "\n// ---------- END ----------\n"
  }
}

case class SumoTerraformDataSourceFileGenerator(terraform: SumoSwaggerTemplate)
  extends SumoTerraformFileGenerator(terraform: SumoSwaggerTemplate) {
  def generate(): String = {
    val pre = """// ----------------------------------------------------------------------------
                |//
                |//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
                |//
                |// ----------------------------------------------------------------------------
                |//
                |//     This file is automatically generated by Sumo Logic and manual
                |//     changes will be clobbered when the file is regenerated. Do not submit
                |//     changes to this file.
                |//
                |// ----------------------------------------------------------------------------
                |package sumologic
                |
                |import (
                |  "errors"
                |  "fmt"
                |  "github.com/hashicorp/terraform-plugin-sdk/helper/schema"
                |  "log"
                |)
                |""".stripMargin

    val dataSourceFunction = SwaggerDataSourceFunctionGenerator(terraform.getMainObjectClass())
    pre + seperatorLine() + terraform.getDataSourceFuncMappings() + seperatorLine() +
      dataSourceFunction.terraformify() + seperatorLine("Converters") +
      getTerraformObjectToResourceDataConverter(terraform.getMainObjectClass())
  }
}

case class SumoTerraformResourceFileGenerator(terraform: SumoSwaggerTemplate)
  extends SumoTerraformFileGenerator(terraform: SumoSwaggerTemplate) {
  def generate(): String = {
    val specialImport = if (terraform.getResourceFuncMappings().contains("Elem:  &schema.Schema{\n            Type: schema.TypeMap,\n           }")) {
      """"github.com/mitchellh/mapstructure""""
    } else {
      ""
    }
    val pre = s"""// ----------------------------------------------------------------------------
                |//
                |//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
                |//
                |// ----------------------------------------------------------------------------
                |//
                |//     This file is automatically generated by Sumo Logic and manual
                |//     changes will be clobbered when the file is regenerated. Do not submit
                |//     changes to this file.
                |//
                |// ----------------------------------------------------------------------------
                |package sumologic
                |
                |import (
                |  "log"
                |  "github.com/hashicorp/terraform-plugin-sdk/helper/schema"
                |  $specialImport
                |)
                |""".stripMargin

    val mappingSchema = terraform.getResourceFuncMappings()

    val ops: String = terraform.supportedEndpoints.map {
      endpoint: SumoSwaggerEndpoint =>
        val gen = SwaggerResourceFunctionGenerator(endpoint, terraform.getMainObjectClass())
        gen.terraformify()
    }.mkString("\n")

    val converters = getTerraformResourceDataToObjectConverter(terraform.getMainObjectClass(), true)

    pre + "\n" + mappingSchema + "\n" + ops + "\n" +
      converters
  }
}

case class SwaggerDataSourceFunctionGenerator(mainClass: SumoSwaggerType) extends SumoTerraformEntity {
  def getTerraformDataResourceSetters(propName: String, objName: String): String = {
    s"""resourceData.Set("$propName", $objName.$propName)""".stripMargin
  }

  override def terraformify(): String = {
    val className = mainClass.name
    val objName = varNameFromTypeName(className)
    /*
    val setters = mainClass.props.map {
      prop: SumoSwaggerObject =>
        val name = prop.getName()
        s"""resourceData.Set("$name", $objName.$name)""".stripMargin
    }.mkString("\n")
    */

    val setter = getTerraformObjectToResourceDataConverterFuncCall(mainClass)
    // Assuming id is of type string
    s"""
       |func dataSourceSumologic${className}Get(resourceData *schema.ResourceData, meta interface{}) error {
       |  client := meta.(*Client)
       |
      |  var $objName *${className}
       |  var err error
       |  if id, ok := resourceData.GetOk("id"); ok {
       |    $objName, err = client.get${className}(id.(string))
       |    if err != nil {
       |      return fmt.Errorf("SumologicTerraformError: ${className} with id %s not found: %v", id, err)
       |    }
       |  } else {
       |      return errors.New("SumologicTerraformError: ${className} object Id is required")
       |    }
       |
      |  resourceData.SetId($objName.id)
       |  $setter
       |
      |  log.Printf("[DEBUG] SumologicTerraformDebug DataSource ${className} : retrieved %v", $objName)
       |  return nil
       |}""".stripMargin
  }
}


case class SwaggerResourceFunctionGenerator(endpoint: SumoSwaggerEndpoint, mainClass: SumoSwaggerType) extends SumoTerraformEntity {

  // TODO: This is gross, generalize if possible
  def generateResourceFunctionGET(): String = {
    val className = mainClass.name
    val objName = varNameFromTypeName(className)

    val setters = mainClass.props.filter(_.getName().toLowerCase != "id").map {
      prop: SumoSwaggerObject =>
        val name = prop.getName()
        s"""d.Set("${removeCamelCase(name)}", $objName.${name.capitalize})""".stripMargin
    }.mkString("\n    ")

    s"""
       |func resourceSumologic${className}Read(d *schema.ResourceData, meta interface{}) error {
       |	c := meta.(*Client)
       |
       |	id := d.Id()
       |	${objName}, err := c.Get${className}(id)
       |
       |	if err != nil {
       |		return err
       |	}
       |
       |	if $objName == nil {
       |		log.Printf("[WARN] $className not found, removing from state: %v - %v", id, err)
       |		d.SetId("")
       |		return nil
       |	}
       |
       |	$setters
       |
       |	return nil
       |}""".stripMargin
  }

  // TODO: This is gross, generalize if possible
  def generateResourceFunctionDELETE(): String = {
    val className = mainClass.name

    s"""func resourceSumologic${className}Delete(d *schema.ResourceData, meta interface{}) error {
       |  client := meta.(*Client)
       |  return client.Delete${className}(d.Id())
       |}""".stripMargin

  }

  // TODO: This is gross, generalize if possible
  def generateResourceFunctionUPDATE(): String = {
    val className = mainClass.name
    val objName = varNameFromTypeName(className)

    val parameter = endpoint.responses.filter {
      response =>
        if (response.respTypeOpt.isDefined) {
          response.respTypeOpt.get.name.toLowerCase.contains(objName.toLowerCase)
        } else {
          false
        }
    }.head.respTypeOpt.get.name

    val lowerCaseName = parameter.substring(0, 1).toLowerCase() + parameter.substring(1)

    s"""
       |func resourceSumologic${className}Update(d *schema.ResourceData, meta interface{}) error {
       |	c := meta.(*Client)
       |
       |	$lowerCaseName := resourceTo${className}(d)
       |
       |	err := c.Update$className($lowerCaseName)
       |
       |	if err != nil {
       |		return err
       |	}
       |
       |	return resourceSumologic${className}Read(d, meta)
       |}""".stripMargin
  }

  // TODO: This is gross, generalize if possible
  def generateResourceFunctionCREATE(): String = {
    val className = mainClass.name
    val objName = varNameFromTypeName(className)

    val parameter = endpoint.responses.filter {
      response =>
        if (response.respTypeOpt.isDefined) {
          response.respTypeOpt.get.name.toLowerCase.contains(objName.toLowerCase)
        } else {
          false
        }
    }.head.respTypeOpt.get.name

    val lowerCaseName = parameter.substring(0, 1).toLowerCase() + parameter.substring(1)

    s"""
       |func resourceSumologic${className}Create(d *schema.ResourceData, meta interface{}) error {
       |	c := meta.(*Client)
       |
       |	if d.Id() == "" {
       |		$lowerCaseName := resourceTo${className}(d)
       |		id, err := c.Create${className}(${lowerCaseName})
       |
       |		if err != nil {
       |			return err
       |		}
       |
       |		d.SetId(id)
       |	}
       |
       |	return resourceSumologic${className}Read(d, meta)
       |}""".stripMargin

  }

  // TODO: This is gross, generalize if possible
  def generateResourceFunctionEXISTS(): String = {
    val className = mainClass.name

    s"""
       |func resourceSumologic${className}Exists(d *schema.ResourceData, meta interface{}) error {
       |	c := meta.(*Client)
       |
       |	_, err := c.Get${className}(d.Id())
       |	if err != nil {
       |		return err
       |	}
       |
       |	return nil
       |}""".stripMargin
  }

  // TODO: This is gross, generalize if possible
  override def terraformify(): String = {

    crud.find {
      op => endpoint.endpointName.toLowerCase.contains(op.toLowerCase) // || endpoint.endpointName.toLowerCase.contains("get")
    } match {
      case Some(opName) => this.getClass.getMethod("generateResourceFunction" + opName.toUpperCase()).invoke(this).toString
      case None => ""
    }
  }
}

case class SumoProviderGenerator(terraform: SumoSwaggerTemplate)
  extends SumoTerraformFileGenerator(terraform: SumoSwaggerTemplate) {
  def generate(): String = {
    val pre = """// ----------------------------------------------------------------------------
                |//
                |//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
                |//
                |// ----------------------------------------------------------------------------
                |//
                |//     This file is automatically generated by Sumo Logic and manual
                |//     changes will be clobbered when the file is regenerated. Do not submit
                |//     changes to this file.
                |//
                |// ----------------------------------------------------------------------------\
                |package main
                |
                |import (
                |  "fmt"
                |  "github.com/go-errors/errors"
                |  "log"
                |  "os"
                |
                |  "github.com/hashicorp/terraform/helper/mutexkv"
                |  "github.com/hashicorp/terraform/terraform"
                |  "github.com/hashicorp/terraform/helper/schema"
                |)
                |
                |const DefaultEnvironment = "us2"
                |
                |func Provider() terraform.ResourceProvider {
                |	defaultEnvironment := os.Getenv("SUMOLOGIC_ENVIRONMENT")
                |	if defaultEnvironment == "" {
                |		defaultEnvironment = DefaultEnvironment
                |	}
                |	log.Printf("[DEBUG] sumo default environment: %s", defaultEnvironment)
                |
                |	return &schema.Provider{
                |		Schema: map[string]*schema.Schema{
                |			"access_id": {
                |				Type:     schema.TypeString,
                |				Optional: true,
                |				Default:  os.Getenv("SUMOLOGIC_ACCESSID"),
                |			},
                |			"access_key": {
                |				Type:     schema.TypeString,
                |				Optional: true,
                |				Default:  os.Getenv("SUMOLOGIC_ACCESSKEY"),
                |			},
                |			"environment": {
                |				Type:     schema.TypeString,
                |				Optional: true,
                |				Default:  defaultEnvironment,
                |			},
                |		},
                |""".stripMargin

    val post = """    ConfigureFunc: providerConfigure,
                 |	}
                 |}
                 |
                 |var SumoMutexKV = mutexkv.NewMutexKV()
                 |
                 |func providerConfigure(d *schema.ResourceData) (interface{}, error) {
                 |	accessId := d.Get("access_id").(string)
                 |	accessKey := d.Get("access_key").(string)
                 |	environment := d.Get("environment").(string)
                 |
                 |	msg := ""
                 |	if accessId == "" {
                 |		msg = "sumologic provider: access_id should be set;"
                 |	}
                 |	if accessKey == "" {
                 |		msg = fmt.Sprintf("%s access_key should be set; ", msg)
                 |	}
                 |	if msg != "" {
                 |		if environment == DefaultEnvironment {
                 |			msg = fmt.Sprintf("%s make sure environment is set or that the default (%s) is appropriate", msg, DefaultEnvironment)
                 |		}
                 |		return nil, errors.New(msg)
                 |	}
                 |
                 |	return NewClient(
                 |		accessId,
                 |		accessKey,
                 |		environment,
                 |	)
                 |}
                |""".stripMargin

    val className = terraform.getMainObjectClass.name
    val lowerCaseClass = className.toLowerCase


    // TODO: make this a list for all classes
    val resourcesMap = s"""    ResourcesMap: map[string]*schema.Resource{
                         |			"sumologic_$lowerCaseClass":          resourceSumologic$className(),
                         |		},
                         |""".stripMargin

    val dataSourcesMap = s"""    DataSourcesMap: map[string]*schema.Resource{
                          |			"sumologic_$lowerCaseClass":          dataSourceSumologic$className(),
                          |		},
                          |""".stripMargin

    pre + resourcesMap + dataSourcesMap + post
  }
}

case class SumoTestGenerator(terraform: SumoSwaggerTemplate, mainClass: String)
  extends SumoTerraformFileGenerator(terraform: SumoSwaggerTemplate) {
  val functionGenerator = SwaggerTestFunctionGenerator(terraform, terraform.getAllTypesUsed().filter(_.name.toLowerCase.contains(mainClass.toLowerCase)).head)
  def generate(): String = {
    val pre = s"""// ----------------------------------------------------------------------------
                 |//
                 |//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
                 |//
                 |// ----------------------------------------------------------------------------
                 |//
                 |//     This file is automatically generated by Sumo Logic and manual
                 |//     changes will be clobbered when the file is regenerated. Do not submit
                 |//     changes to this file.
                 |//
                 |// ----------------------------------------------------------------------------
                 |package sumologic
                 |
                 |import (
                 |	"fmt"
                 |	"testing"
                 |  "strconv"
                 |  "strings"
                 |	"github.com/hashicorp/terraform-plugin-sdk/helper/resource"
                 |	"github.com/hashicorp/terraform-plugin-sdk/terraform"
                 |)
                 |""".stripMargin
    pre + functionGenerator.generateTestFunctionCreateBasic() + "\n" + functionGenerator.generateTestFunctionCreate() + "\n" + functionGenerator.generateTestFunctionDestroy() +
      functionGenerator.generateTestFunctionExists() + "\n" + functionGenerator.generateTestFunctionUpdate() + "\n" + functionGenerator.generateTestImportFunction() + "\n" +
      functionGenerator.generateTestCreateResource() + "\n" + functionGenerator.generateTestUpdateResource() + "\n" + functionGenerator.generateTestResourceAttributes()
  }
}

case class SwaggerTestFunctionGenerator(sumoSwaggerTemplate: SumoSwaggerTemplate, mainClass: SumoSwaggerType) extends SumoTerraformEntity {
  val className = mainClass.name
  val objName = className.substring(0, 1).toLowerCase() + className.substring(1)
  val resourceProps = sumoSwaggerTemplate.getAllTypesUsed().head

  def generateTestFunctionCreateBasic(): String = {
    val setters = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        prop.getType.name match {
          case "array" =>
            s"""test${prop.getName.capitalize} := []string{"\"" + FieldsMap["${className}Basic"]["${prop.getName()}"] + "\""}"""
          case "bool" =>
            s"""test${prop.getName.capitalize}, _ := strconv.ParseBool(FieldsMap["${className}Basic"]["${prop.getName()}"])"""
          case _ =>
            if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
              s"""test${prop.getName.capitalize} := []string{"\\"" + FieldsMap["${className}Basic"]["${prop.getName()}"] + "\\""}"""
            } else {
              s"""test${prop.getName.capitalize} := FieldsMap["${className}Basic"]["${prop.getName()}"]"""
            }
        }
    }.mkString("\n  ")

    val testNames = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        s"""test${prop.getName.capitalize}"""
    }.mkString(", ")

    s"""func TestAccSumologic${className}_basic(t *testing.T) {
       |	var $objName $className
       |	$setters
       |
       |	resource.Test(t, resource.TestCase{
       |		PreCheck:     func() { testAccPreCheck(t) },
       |		Providers:    testAccProviders,
       |		CheckDestroy: testAccCheck${className}Destroy($objName),
       |		Steps: []resource.TestStep{
       |			{
       |				Config: testAccCheckSumologic${className}ConfigImported($testNames),
       |			},
       |			{
       |				ResourceName:      "sumologic_$objName.foo",
       |				ImportState:       true,
       |				ImportStateVerify: true,
       |			},
       |		},
       |	})
       |}""".stripMargin
  }

  def generateTestFunctionCreate(): String = {
    val setters = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        prop.getType.name match {
          case "array" =>
            s"""test${prop.getName.capitalize} := []string{"\"" + FieldsMap["${className}"]["${prop.getName()}"] + "\""}"""
          case "bool" =>
            s"""test${prop.getName.capitalize}, _ := strconv.ParseBool(FieldsMap["$className"]["${prop.getName()}"])"""
          case _ =>
            if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
              s"""test${prop.getName.capitalize} := []string{"\\"" + FieldsMap["${className}"]["${prop.getName()}"] + "\\""}"""
            } else {
              s"""test${prop.getName.capitalize} := FieldsMap["$className"]["${prop.getName()}"]"""
            }
        }
    }.mkString("\n  ")

    val testNames = "(" + resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        s"""test${prop.getName.capitalize}"""
    }.mkString(", ")

    val checkAttr = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        prop.getType.name match {
          case "bool" =>
            s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}", strconv.FormatBool(test${prop.getName.capitalize})),"""
          case "array" =>
            s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}.0", strings.Replace(test${prop.getName.capitalize}[0], "\\"", "", 2)),"""
          case _ =>
            if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
              s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}.0", strings.Replace(test${prop.getName.capitalize}[0], "\\"", "", 2)),"""
            } else {
              s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}", test${prop.getName.capitalize}),"""
            }
        }
    }.mkString("\n          ")

    s"""func TestAcc${className}_create(t *testing.T) {
       |  var ${objName} ${className}
       |  $setters
       |  resource.Test(t, resource.TestCase{
       |    PreCheck: func() { testAccPreCheck(t) },
       |    Providers:    testAccProviders,
       |    CheckDestroy: testAccCheck${className}Destroy(${objName}),
       |    Steps: []resource.TestStep{
       |      {
       |        Config: testAccSumologic${className}$testNames),
       |        Check: resource.ComposeTestCheckFunc(
       |          testAccCheck${className}Exists("sumologic_${objName}.test", &${objName}, t),
       |          testAccCheck${className}Attributes("sumologic_${objName}.test"),
       |          $checkAttr
       |        ),
       |      },
       |    },
       |  })
       |}""".stripMargin
  }

  def generateTestFunctionDestroy(): String = {
    s"""
       |func testAccCheck${className}Destroy(${objName} ${className}) resource.TestCheckFunc {
       |	return func(s *terraform.State) error {
       |		client := testAccProvider.Meta().(*Client)
       |    for _, r := range s.RootModule().Resources {
       |      id := r.Primary.ID
       |		  u, err := client.Get${className}(id)
       |		  if err != nil {
       |        return fmt.Errorf("Encountered an error: " + err.Error())
       |		  }
       |      if u != nil {
       |        return fmt.Errorf("${className} still exists")
       |      }
       |    }
       |		return nil
       |	}
       |}
       |""".stripMargin
  }

  def generateTestFunctionExists(): String = {
    s"""func testAccCheck${className}Exists(name string, ${objName} *${className}, t *testing.T) resource.TestCheckFunc {
       |	return func(s *terraform.State) error {
       |		rs, ok := s.RootModule().Resources[name]
       |		if !ok {
       |      //need this so that we don't get an unused import error for strconv in some cases
       |			return fmt.Errorf("Error = %s. ${className} not found: %s", strconv.FormatBool(ok), name)
       |		}
       |
       |    //need this so that we don't get an unused import error for strings in some cases
       |		if strings.EqualFold(rs.Primary.ID, "") {
       |			return fmt.Errorf("${className} ID is not set")
       |		}
       |
       |		id := rs.Primary.ID
       |		c := testAccProvider.Meta().(*Client)
       |		new${className}, err := c.Get${className}(id)
       |		if err != nil {
       |			return fmt.Errorf("${className} %s not found", id)
       |		}
       |		${objName} = new${className}
       |		return nil
       |	}
       |}""".stripMargin
  }

  def generateTestFunctionUpdate(): String = {
    val testArguments = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        prop.getType.name match {
          case "array" =>
            s"""test${prop.getName.capitalize} := []string{"\"" + FieldsMap["${className}"]["${prop.getName()}"] + "\""}"""
          case "bool" =>
            s"""test${prop.getName.capitalize}, _ := strconv.ParseBool(FieldsMap["$className"]["${prop.getName()}"])"""
          case _ =>
            if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
              s"""test${prop.getName.capitalize} := []string{"\\"" + FieldsMap["${className}"]["${prop.getName()}"] + "\\""}"""
            } else {
              s"""test${prop.getName.capitalize} := FieldsMap["$className"]["${prop.getName()}"]"""
            }
        }
    }.mkString("\n  ")
    val testUpdateArguments = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        prop.getType.name match {
          case "array" =>
            s"""testUpdated${prop.getName.capitalize} := []string{"\"" + FieldsMap["${className}"]["updated${prop.getName().capitalize}"] + "\""}"""
          case "bool" =>
            s"""testUpdated${prop.getName.capitalize}, _ := strconv.ParseBool(FieldsMap["$className"]["updated${prop.getName().capitalize}"])"""
          case _ =>
            if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
              s"""testUpdated${prop.getName.capitalize} := []string{"\\"" + FieldsMap["${className}"]["updated${prop.getName().capitalize}"] + "\\""}"""
            } else {
              s"""testUpdated${prop.getName.capitalize} := FieldsMap["$className"]["updated${prop.getName().capitalize}"]"""
            }
        }
    }.mkString("\n  ")
    val argList = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop => s"""test${prop.getName().capitalize}"""
    }.mkString(", ")
    val checkAttr = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        prop.getType.name match {
          case "bool" =>
            s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}", strconv.FormatBool(test${prop.getName.capitalize})),"""
          case "array" =>
            s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}.0", strings.Replace(test${prop.getName.capitalize}[0], "\\"", "", 2)),"""
          case _ =>
            if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
              s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}.0", strings.Replace(test${prop.getName.capitalize}[0], "\\"", "", 2)),"""
            } else {
              s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}", test${prop.getName.capitalize}),"""
            }
        }
    }.mkString("\n          ")
    val updateArgList = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop => s"""testUpdated${prop.getName().capitalize}"""
    }.mkString(", ")
    val checkUpdateAttr = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        prop.getType.name match {
          case "bool" =>
            s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}", strconv.FormatBool(testUpdated${prop.getName.capitalize})),"""
          case "array" =>
            s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}.0", strings.Replace(testUpdated${prop.getName.capitalize}[0], "\\"", "", 2)),"""
          case _ =>
            if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
              s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}.0", strings.Replace(testUpdated${prop.getName.capitalize}[0], "\\"", "", 2)),"""
            } else {
              s"""resource.TestCheckResourceAttr("sumologic_$objName.test", "${removeCamelCase(prop.getName())}", testUpdated${prop.getName.capitalize}),"""
            }
        }
    }.mkString("\n          ")

    s"""
       |func TestAcc${className}_update(t *testing.T) {
       |  var ${objName} ${className}
       |  $testArguments
       |
       |  $testUpdateArguments
       |
       |	resource.Test(t, resource.TestCase{
       |		PreCheck: func() { testAccPreCheck(t) },
       |		Providers:    testAccProviders,
       |		CheckDestroy: testAccCheck${className}Destroy($objName),
       |		Steps: []resource.TestStep{
       |			{
       |				Config: testAccSumologic${className}($argList),
       |				Check: resource.ComposeTestCheckFunc(
       |					testAccCheck${className}Exists("sumologic_$objName.test", &$objName, t),
       |					testAccCheck${className}Attributes("sumologic_$objName.test"),
       |          $checkAttr
       |				),
       |			},
       |			{
       |				Config: testAccSumologic${className}Update($updateArgList),
       |				Check: resource.ComposeTestCheckFunc(
       |					$checkUpdateAttr
       |				),
       |			},
       |		},
       |	})
       |}""".stripMargin
  }

  def generateTestImportFunction(): String = {
    val propArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        val name = if (ForbiddenGoTerms.forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName()
        }
        if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
          s"""${name} ${SumoTerraformSchemaTypes.swaggerTypeToGoType("array")}"""
        } else {
          s"""${name} ${SumoTerraformSchemaTypes.swaggerTypeToGoType(prop.getType.name.toLowerCase)}"""
        }
    }.mkString(", ")
    val terraformArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
          s"""${removeCamelCase(prop.getName())} = ${SumoTerraformSchemaTypes.swaggerTypeToPlaceholder("array")}"""
        } else {
          s"""${removeCamelCase(prop.getName())} = ${SumoTerraformSchemaTypes.swaggerTypeToPlaceholder(prop.getType.name)}"""
        }
    }.mkString("\n      ")
    val propList = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        if (ForbiddenGoTerms.forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName()
        }
    }.mkString(", ")
    s"""func testAccCheckSumologic${className}ConfigImported($propArgs) string {
       |	return fmt.Sprintf(`
       |resource "sumologic_$objName" "foo" {
       |      $terraformArgs
       |}
       |`, $propList)
       |}""".stripMargin
  }

  def generateTestCreateResource(): String = {
    val propArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        val name = if (ForbiddenGoTerms.forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName()
        }
        if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
          s"""${name} ${SumoTerraformSchemaTypes.swaggerTypeToGoType("array")}"""
        } else {
          s"""${name} ${SumoTerraformSchemaTypes.swaggerTypeToGoType(prop.getType.name.toLowerCase)}"""
        }
    }.mkString(", ")
    val terraformArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
          s"""${removeCamelCase(prop.getName())} = ${SumoTerraformSchemaTypes.swaggerTypeToPlaceholder("array")}"""
        } else {
          s"""${removeCamelCase(prop.getName())} = ${SumoTerraformSchemaTypes.swaggerTypeToPlaceholder(prop.getType.name)}"""
        }
    }.mkString("\n    ")
    val propList = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        if (ForbiddenGoTerms.forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName()
        }
    }.mkString(", ")

    s"""
       |func testAccSumologic${className}($propArgs) string {
       |	return fmt.Sprintf(`
       |resource "sumologic_${objName}" "test" {
       |    $terraformArgs
       |}
       |`, $propList)
       |}""".stripMargin
  }

  def generateTestUpdateResource(): String = {
    val propArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        val name = if (ForbiddenGoTerms.forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName()
        }
        if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
          s"""${name} ${SumoTerraformSchemaTypes.swaggerTypeToGoType("array")}"""
        } else {
          s"""${name} ${SumoTerraformSchemaTypes.swaggerTypeToGoType(prop.getType.name.toLowerCase)}"""
        }
    }.mkString(", ")
    val terraformArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        if (prop.isInstanceOf[SumoSwaggerObjectArray]) {
          s"""${removeCamelCase(prop.getName())} = ${SumoTerraformSchemaTypes.swaggerTypeToPlaceholder("array")}"""
        } else {
          s"""${removeCamelCase(prop.getName())} = ${SumoTerraformSchemaTypes.swaggerTypeToPlaceholder(prop.getType.name)}"""
        }
    }.mkString("\n      ")
    val propList = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        if (ForbiddenGoTerms.forbidden.contains(prop.getName.toLowerCase)) {
          prop.getName + "_field"
        } else {
          prop.getName()
        }
    }.mkString(", ")

    s"""
       |func testAccSumologic${className}Update($propArgs) string {
       |	return fmt.Sprintf(`
       |resource "sumologic_${objName}" "test" {
       |      $terraformArgs
       |}
       |`, $propList)
       |}""".stripMargin
  }

  def generateTestResourceAttributes(): String = {
    val checkResourceAttr = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        s"""resource.TestCheckResourceAttrSet(name, "${removeCamelCase(prop.getName())}"),"""
    }.mkString("\n        ")

    s"""
       |func testAccCheck${className}Attributes(name string) resource.TestCheckFunc {
       |  return func(s *terraform.State) error {
       |      f := resource.ComposeTestCheckFunc(
       |        $checkResourceAttr
       |      )
       |      return f(s)
       |   }
       |}""".stripMargin
  }

}

case class SumoDocsGenerator(terraform: SumoSwaggerTemplate, mainClass: String)
  extends SumoTerraformFileGenerator(terraform: SumoSwaggerTemplate) {
  val functionGenerator = SwaggerDocsFunctionGenerator(terraform, terraform.getAllTypesUsed().filter(_.name.toLowerCase.contains(mainClass.toLowerCase)).head)
  def generate(): String = {
    functionGenerator.generateLayout() + functionGenerator.generateHeader() + functionGenerator.generateExampleUsage() + functionGenerator.generateArgReferences() + functionGenerator.generateFooter()
  }
}

case class SwaggerDocsFunctionGenerator(sumoSwaggerTemplate: SumoSwaggerTemplate, mainClass: SumoSwaggerType) extends SumoTerraformEntity {
  val className = mainClass.name
  val objName = className.substring(0, 1).toLowerCase() + className.substring(1)
  val resourceProps = sumoSwaggerTemplate.getAllTypesUsed().head

  def generateLayout(): String = {
    s"""---
       |layout: "sumologic"
       |page_title: "SumoLogic: sumologic_${removeCamelCase(objName)}"
       |description: |-
       |  Provides a Sumologic ${addSpace(className)}
       |---
       |""".stripMargin
  }

  def generateHeader(): String = {
    s"""
       |# sumologic_$objName
       |Provider to manage Sumologic ${addSpace(className)}s
       |
       |""".stripMargin
  }

  def generateExampleUsage(): String = {
    val terraformArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        s"""${removeCamelCase(prop.getName())} = "${prop.getExample()}""""
    }.mkString("\n    ")

    s"""## Example Usage
       |```hcl
       |resource "sumologic_${removeCamelCase(objName)}" "example_${removeCamelCase(objName)}" {
       |    $terraformArgs
       |}
       |```
       |""".stripMargin
  }

  def generateArgReferences(): String = {
    val terraformArgs = resourceProps.props.filter(_.getName.toLowerCase != "id").map {
      prop =>
        if (prop.getRequired()) {
          s"""- `${removeCamelCase(prop.getName())}` - (Required) ${prop.getDescription()}"""
        } else {
          s"""- `${removeCamelCase(prop.getName())}` - (Optional) ${prop.getDescription()}"""
        }
    }.mkString("\n")

    val exportedArgs = if (resourceProps.props.map(_.getName.toLowerCase).contains("id")) {
      s"""The following attributes are exported:
        |
        |- `id` - The internal ID of the ${removeCamelCase(objName)}
        |""".stripMargin
    } else {
      ""
    }

    s"""## Argument reference
       |
       |The following arguments are supported:
       |
       |$terraformArgs
       |
       |$exportedArgs
       |
       |""".stripMargin
  }

  def generateFooter(): String = {
    s"""
       |[Back to Index][0]
       |
       |[0]: ../README.md
       |""".stripMargin
  }
}
